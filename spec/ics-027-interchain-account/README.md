---
ics: 27  
title: Interchain Account  
stage: Draft  
category: IBC/TAO  
author: Tony Yun <yunjh1994@everett.zone>, Dogemos <josh@tendermint.com>  
created: 2019-08-01  
modified: 2019-11-08  
---  

## Synopsis  

This standard document specifies packet data structure, state machine handling logic, and encoding details for the account management system over an IBC channel between separate chains.  

### Motivation  

On Ethereum, there are two types of accounts: externally owned accounts, controlled by private keys, and contract accounts, controlled by their contract code [[ref](https://github.com/ethereum/wiki/wiki/White-Paper)]. Similar to Ethereum's CA (contract accounts), interchain accounts are managed by another chain while retaining all the capabilities of a normal account (i.e. stake, send, vote, etc). While an Ethereum CA's contract logic is performed within Ethereum's EVM, interchain accounts are managed by another chain via IBC in a way such that the owner of the account retains full control over how it behaves.  

### Definitions  

The IBC handler interface & IBC relayer module interface are as defined in [ICS 25](https://github.com/cosmos/ics/blob/bez/15-ics-cosmos-signed-messages/spec/ics-025-handler-interface) and [ICS 26](https://github.com/cosmos/ics/blob/bez/15-ics-cosmos-signed-messages/spec/ics-026-relayer-module), respectively.  

### Desired Properties  

- Permissionless  
- Fault containment: Interchain account must follow rules of its host chain, even in times of Byzantine behavior by the counterparty chain (the chain that manages the account)  
- The chain that controls the account must process the results asynchronously and according to the chain's logic.  
- Sending and receiving transactions will be processed in an ordered manner.  

## Technical Specification  

The implementation of interchain account is non-symmetric. This means that each chain can have a different way to generate an interchain account and deserialize the transaction bytes and a different set of transactions that they can execute. For example, chains that use cosmos-sdk will deserialize tx bytes by Amino, but if counterparty chain is a smart contract on Ethereum, it may deserialize tx bytes by ABI that is minimal serializing algorithm for smart contract.  
Interchain account specification defines the general way to register interchain account and transfer tx bytes, and counterparty chain is responsible to deserialize and execute the tx bytes, and sending chain should know how counterparty chain handle tx bytes in advance.

Each chain must satisfy following features to create a interchain account:

- New interchain accounts must not conflict with existing ones.
- Each chain must keep track of which counterparty chain created each new interchain account.

Also, each chain must know how the counterparty chains serialize/deserialize transaction bytes in order to send transactions via IBC. And the counterparty chain must implement the process of safely exececuting IBC transactions by verifying the authority of the transaction's signers.

The chain must reject the transaction and must not make a state transition in the following cases:

- The IBC transaction fails to be deserialized.
- The IBC transaction requests for signers that was not made by counterparty chain.

### Data Structures

Each chain must implement below interfaces to support interchain account. ```createOutgoingPacket``` method in ```IBCAccountModule``` interface defines the way how to create an outgoing packet for a specific type. Type indicates how IBC account transaction should be constructed and serialized for the host chain. Generally, type indicates what framework the host chain was built from.  
```generateAddress``` defines the way how to determine the account's address by using identifier and salt. Using the salt to generate an address is recommended, but not required. If the chain don't support the way to generate an address with salt deterministically, it can be generated by its own way. ```createAccount``` is used to create account with genereated address. New interchain account must not conflict with existing one, and chains should keep track of which counterparty chain created the new interchain account in order to verify the authority of transaction's singers in ```authenticateTx```.
```authenticateTx``` validates a transaction and check the signers in the transaction have right permissions. ```runTx``` executes tx after the transaction was authenticated successfully.

```typescript
interface IBCAccountModule {
  createOutgoingPacket(chainType: Uint8Array, data: any)
  createAccount(address: Uint8Array)
  generateAddress(identifier: Identifier, salt: Uint8Array): Uint8Array
  deserializeTx(txBytes: Uint8Array): Tx
  authenticateTx(tx: Tx): boolean
  runTx(tx: Tx): uint32
}
```

`RegisterIBCAccountPacketData` is used for counterparty chain to register an account. Interchain account's address is defined deterministically with channel identifier and salt. ```generateAccount``` method in module is used to generate interchain account's address. It is recommended to generate address by ```hash(identifier+salt)```, but it doesn't impose a particular process. It must generate unique and deterministic address by utilizing identifier and salt.

```typescript  
interface RegisterIBCAccountPacketData {  
  salt: Uint8Array  
}  
```

`RunTxPacketData` is used to run tx for interchain account. Tx bytes is dependent on app, and it is formed with minimal data set except data for validating signatures.  

```typescript  
interface RunTxPacketData {  
  txBytes: Uint8Array  
}  
```

```IBCAccountHandler``` interface helps the developers to get results from interactions with interchain account. 

```typescript
interface InterchainTxHandler {
  onAccountCreated(identifier: Identifier, address: Address)
  onTxSucceeded(identifier: Identifier, txBytes: Uint8Array)
  onTxFailed(identifier: Identifier, txBytes: Uint8Array, errorCode: Uint8Array)
}
```

### Subprotocols  

The subprotocols described herein should be implemented in a "interchain-account-bridge" module with access to a router and codec (decoder or unmarshaller) for app and to the IBC relayer module.  

### Port & channel setup  

The `setup` function must be called exactly once when the module is created (perhaps when the blockchain itself is initialized) to bind to the appropriate port and create an escrow address (owned by the module).  

```typescript  
function setup() {  
  relayerModule.bindPort("interchain-account", ModuleCallbacks{  
    onChanOpenInit,  
    onChanOpenTry,  
    onChanOpenAck,  
    onChanOpenConfirm,  
    onChanCloseInit,  
    onChanCloseConfirm,  
    onSendPacket,  
    onRecvPacket,  
    onTimeoutPacket,  
    onAcknowledgePacket,  
    onTimeoutPacketClose  
  })  
}  
```

Once the `setup` function has been called, channels can be created through the IBC relayer module between instances of the interchain account module on separate chains.  

An administrator (with the permissions to create connections & channels on the host state machine) is responsible for setting up connections to other state machines & creating channels to other instances of this module (or another module supporting this interface) on other chains. This specification defines packet handling semantics only, and defines them in such a fashion that the module itself doesn't need to worry about what connections or channels might or might not exist at any point in time.

### Routing module callbacks  

### Channel lifecycle management  

Both machines `A` and `B` accept new channels from any module on another machine, if and only if:  

- The other module is bound to the "interchain account" port.  
- The channel being created is ordered.  
- The version string is empty.  

```typescript  
function onChanOpenInit(  
  order: ChannelOrder,  
  connectionHops: [Identifier],  
  portIdentifier: Identifier,  
  channelIdentifier: Identifier,  
  counterpartyPortIdentifier: Identifier,  
  counterpartyChannelIdentifier: Identifier,  
  version: string) {  
  // only ordered channels allowed  
  abortTransactionUnless(order === ORDERED)  
  // only allow channels to "interchain-account" port on counterparty chain  
  abortTransactionUnless(counterpartyPortIdentifier === "interchain-account")  
  // version not used at present  
  abortTransactionUnless(version === "")  
}  
```

```typescript  
function onChanOpenTry(  
  order: ChannelOrder,  
  connectionHops: [Identifier],  
  portIdentifier: Identifier,  
  channelIdentifier: Identifier,  
  counterpartyPortIdentifier: Identifier,  
  counterpartyChannelIdentifier: Identifier,  
  version: string,  
  counterpartyVersion: string) {  
  // only ordered channels allowed  
  abortTransactionUnless(order === ORDERED)  
  // version not used at present  
  abortTransactionUnless(version === "")  
  abortTransactionUnless(counterpartyVersion === "")  
  // only allow channels to "interchain-account" port on counterparty chain  
  abortTransactionUnless(counterpartyPortIdentifier === "interchain-account")  
}  
```

```typescript  
function onChanOpenAck(  
  portIdentifier: Identifier,  
  channelIdentifier: Identifier,  
  version: string) {  
  // version not used at present  
  abortTransactionUnless(version === "")  
  // port has already been validated  
}  
```

```typescript  
function onChanOpenConfirm(  
  portIdentifier: Identifier,  
  channelIdentifier: Identifier) {  
  // accept channel confirmations, port has already been validated  
}  
```

```typescript  
function onChanCloseInit(  
  portIdentifier: Identifier,  
  channelIdentifier: Identifier) {  
  // no action necessary  
}  
```

```typescript  
function onChanCloseConfirm(  
  portIdentifier: Identifier,  
  channelIdentifier: Identifier) {  
  // no action necessary  
}  
```

### Packet relay  

In plain English, between chains `A` and `B`. It will describe only the case that chain A wants to register an Interchain account on chain B and control it. Moreover, this system can also be applied the other way around.  

```typescript  
function onRecvPacket(packet: Packet): bytes {  
  if (packet.data is RunTxPacketData) {  
    const tx = deserializeTx(packet.data.txBytes)
    abortTransactionUnless(authenticateTx(tx) == true)
    return runTx(tx)
  }  
      
  if (packet.data is RegisterIBCAccountPacketData) {  
    RegisterIBCAccountPacketData data = packet.data  
    identifier = "{packet/sourcePort}/{packet.sourceChannel}"  
    const address = generateAddress(identifier, packet.salt)
    createAccount(address)
    // Return generated address.
    return address
  }   
      
  return 0x  
}  
```

```typescript  
function onAcknowledgePacket(  
  packet: Packet,  
  acknowledgement: bytes) {  
  if (packet.data is RegisterIBCAccountPacketData) {
    if (acknowledgement !== 0x) {
      identifier = "{packet/sourcePort}/{packet.sourceChannel}"
      onAccountCreated(identifier, acknowledgement)
    }
  }
  if (packet.data is RunTxPacketData) {
    identifier = "{packet/destPort}/{packet.destChannel}"  
    if (acknowledgement === 0x) {
        onTxSucceeded(identifier: Identifier, packet.data.txBytes)
    } else {
        onTxFailed(identifier: Identifier, packet.data.txBytes, acknowledgement)
    }
  }
}  
```

```typescript  
function onTimeoutPacket(packet: Packet) {  
  // Receiving chain should handle this event as if the tx in packet has failed  
  if (packet.data is RunTxPacketData) {
    identifier = "{packet/destPort}/{packet.destChannel}"  
    // 0x99 error code means timeout.
    onTxFailed(identifier: Identifier, packet.data.txBytes, 0x99)
  }
}  
```

```typescript  
function onTimeoutPacketClose(packet: Packet) {  
  // nothing is necessary  
}  
```

## Backwards Compatibility  

Not applicable.

## Forwards Compatibility  

Not applicable.

## Example Implementation  

Pseudocode for cosmos-sdk: https://github.com/everett-protocol/everett-hackathon/tree/master/x/interchain-account  
POC for Interchain account on Ethereum: https://github.com/everett-protocol/ethereum-interchain-account

## Other Implementations  

(links to or descriptions of other implementations)  

## History  

01 August 2019 - Concept discussed  
24 September 2019 - Draft suggested  
8  November 2019 - Major revisions  

## Copyright  

All content herein is licensed under [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0).
