\documentclass[border=2pt]{standalone}
\usepackage{amsmath}
\usepackage{varwidth}
\usepackage{color}
\usepackage{algpseudocode}

\algdef{SE}[SUBALG]{Indent}{EndIndent}{}{\algorithmicend\ }%
\algtext*{Indent}
\algtext*{EndIndent}

\algblockdefx[Struct]{Struct}{EndStruct}%
    [2][Unknown]{struct \textsc{#1} \textbf{#2} \{}%
    {\}}

\algnewcommand\Field[2]{\State \textsc{#1} #2}

\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}%
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%

\makeatletter
\renewcommand{\ALG@beginalgorithmic}{\tiny}
\makeatother

\begin{document}
\begin{varwidth}{\linewidth}

\begin{algorithmic}
\Struct[Datagram]{OPENINIT}
\Field{Version}{desiredVersion}
\Field{RootOfTrust}{rootOfTrustB}
\Field{Identifier}{identifierA}
\Field{Identifier}{desiredIdentifierB}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Struct[Datagram]{OPENTRY}
\Field{Version}{desiredVersion}
\Field{RootOfTrust}{rootOfTrustA}
\Field{Identifier}{identifierA}
\Field{Identifier}{desiredIdentifierB}
\Field{AccumulatorProof}{proofInitA}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Struct[Datagram]{OPENACK}
\Field{Version}{agreedVersion}
\Field{Identifier}{agreedIdentifierB}
\Field{AccumulatorProof}{proofTryB}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Struct[Datagram]{OPENCONFIRM}
\Field{AccumulatorProof}{proofAckA}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Struct[Enum]{STATE}
\Field{INIT}{}
\Field{TRY}{}
\Field{OPEN}{}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Function{handleDatagram}{datagram}
  \Switch{$datagram$}
    \Case{$OPENINIT$}
      \State \Call{Store}{identifierA, <desiredVersion, rootOfTrustB, desiredIdentifierB>}
      \State $state \gets INIT$
    \EndCase
    \Case{$OPENTRY$}
      \Assert{\Call{verify}{rootOfTrustA, proofInitA}}
      \Assert{\Call{getRootOfTrust}{} $==$ rootOfTrustB}
      \State $identifierB \gets $\Call{chooseIdentifier}{desiredIdentifierB}
      \State $versionB \gets $\Call{chooseVersion}{desiredVersionB}
      \State \Call{Store}{identifierB, <version, rootOfTrustA, identifierA>}
      \State $state \gets TRY$
    \EndCase
    \Case{$OPENACK$}
      \Assert{$state == INIT$}
      \Assert{\Call{verify}{rootOfTrustB, proofTryB}}
      \Assert{\Call{getRootOfTrust}{} $==$ rootOfTrustA}
      \Assert{\Call{checkIdentifier}{desiredIdentifierB, identifierB}}
      \Assert{\Call{checkVersion}{desiredVersion, version}}
      \State \Call{Store}{identifierA, <version, rootOfTrustB, identifierB>}
      \State $state \gets OPEN$
    \EndCase
    \Case{$OPENCONFIRM$}
      \Assert{$state == TRY$}
      \Assert{\Call{verify}{rootOfTrustA, proofAckA}}
      \State $state \gets OPEN$
    \EndCase
  \EndSwitch
\EndFunction
\end{algorithmic}

\end{varwidth}
\end{document}
