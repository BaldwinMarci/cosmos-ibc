\include{common}

\begin{document}
\begin{varwidth}{\linewidth}

\begin{algorithmic}
\Struct[Datagram]{ConnOpenInit}
\Field{Identifier}{identifier}
\Description{Identifier to use for connection on chain A}
\Field{Identifier}{desiredCounterpartyIdentifier}
\Description{Desired identifier to use for connection on chain B}
\Field{Version}{desiredVersion}
\Description{Desired version for connection}
\Field{RootOfTrust}{rootOfTrust}
\Description{Root-of-trust for chain B}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Struct[Datagram]{ConnOpenTry}
\Field{Identifier}{desiredIdentifier}
\Description{Desired identifier to use for connection on chain B}
\Field{Identifier}{counterpartyIdentifier}
\Description{Identifier for connection on chain A}
\Field{Version}{desiredVersion}
\Description{Desired version for connection}
\Field{RootOfTrust}{rootOfTrust}
\Description{Root-of-trust for chain A}
\Field{AccumulatorProof}{proofInit}
\Description{Proof of stored INIT state on chain A}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Struct[Datagram]{ConnOpenAck}
\Field{Identifier}{identifier}
\Description{Identifier for connection on chain A}
\Field{Identifier}{agreedCounterpartyIdentifier}
\Description{Identifier for connection on chain B}
\Field{Version}{agreedVersion}
\Description{Agreed version for connection}
\Field{AccumulatorProof}{proofTry}
\Description{Proof of stored TRY state on chain B}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Struct[Datagram]{ConnOpenConfirm}
\Field{Identifier}{identifier}
\Description{Identifier for connection on chain B}
\Field{AccumulatorProof}{proofAck}
\Description{Proof of stored OPEN state on chain A}
\EndStruct
\end{algorithmic}

\begin{algorithmic}
\Function{handleDatagram}{datagram}
  \Switch{$datagram$}
    \Case{$ConnOpenInit$}
      \Assert{\Call{Get}{identifier} $== null$} 
      \State $state \gets INIT$
      \State \Call{Set}{identifier, (state, desiredVersion, desiredCounterpartyIdentifier, rootOfTrust)}
    \EndCase
    \Case{$ConnOpenTry$}
      \State $expectedRootOfTrust \gets$ \Call{getRootOfTrust}{ }
      \Assert{\Call{verify}{rootOfTrust, proofInit,\par
        \hskip3em (counterpartyIdentifier, (INIT, desiredVersion, desiredIdentifier, expectedRootOfTrust))}}
      \State $identifier \gets$ \Call{chooseIdentifier}{desiredIdentifier, counterpartyIdentifier}
      \State $version \gets$ \Call{chooseVersion}{desiredVersion}
      \State $state \gets OPENTRY$
      \State \Call{Set}{identifier, (state, version, counterpartyIdentifier, rootOfTrust)}
    \EndCase
    \Case{$ConnOpenAck$}
      \State $(state, desiredVersion, desiredCounterpartyIdentifier, rootOfTrust) \gets $\Call{Get}{identifier}
      \Assert{$state == INIT$}
      \State $expectedRootOfTrust \gets$ \Call{getRootOfTrust}{ }
      \Assert{\Call{verify}{rootOfTrust, proofTry,\par
        \hskip3em (agreedCounterpartyIdentifier, (OPENTRY, agreedVersion, identifier, expectedRootOfTrust))}}
      \Assert{\Call{checkIdentifier}{desiredCounterpartyIdentifier, agreedCounterpartyIdentifier}}
      \Assert{\Call{checkVersion}{desiredVersion, agreedVersion}}
      \State $state \gets OPEN$
      \State \Call{Set}{identifier, (state, agreedVersion, agreedCounterpartyIdentifier, rootOfTrust)}
    \EndCase
    \Case{$ConnOpenConfirm$}
      \State $(state, version, counterpartyIdentifier, rootOfTrust) \gets$ \Call{Get}{identifier}
      \Assert{$state == OPENTRY$}
      \State $expectedRootOfTrust \gets$ \Call{getRootOfTrust}{ }
      \Assert{\Call{verify}{rootOfTrust, proofAck,\par
        \hskip3em (counterpartyIdentifier, (OPEN, version, identifier, expectedRootOfTrust)}}
      \State $state \gets OPEN$
      \State \Call{Set}{identifier, (state, version, counterpartyIdentifier, rootOfTrust)}
    \EndCase
  \EndSwitch
\EndFunction
\end{algorithmic}

\end{varwidth}
\end{document}
