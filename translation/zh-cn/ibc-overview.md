# IBC Architectural Overview / IBC 架构性概览

## Abstraction Definitions / 抽象定义：

### **Actor / 参与者**

角色或用户是在跨链通信中进行交互的实体。一个参与者可以是一个终端用户，在区块链上运行的模块或智能合约，或者是能够签署交易的链下中继器进程。

### **Machine / Chain / Ledger / 机器 / 链 / 账本**

机器，链，块链或账本（可互换使用）是实现IBC规范的一部分或全部的状态机（并不需要严格意义上的区块链，可以是分布式账本或者链）。

### **Relayer process / 中继链进程**

“中继链进程”是一个链下进程，负责通过扫描两个或更多机器的状态并提交交易来在两台或多台机器之间中继 IBC 数据包和元数据。

### **State Machine / 状态机**

特定链的状态机定义状态的结构以及一组规则，这些规则确定有效的交易，这些交易基于链的共识算法所认同的当前状态来触发状态转换。

### **Consensus / 共识**

共识算法是一组操作分布式账本的进程使用的协议，通常在存在一定数量的拜占庭式故障的情况下就同一状态达成协议。

### **Consensus State / 共识状态**

共识状态是关于共识算法状态的一组信息，该状态信息用于验证关于该共识算法输出的证明。

### **Commitment / 承诺**

加密承诺是一种廉价地验证键/值对映射中的成员是否存在的方法，其中可以使用较短的见证字符串来落实映射。

### **Header / 区块头**

区块头是对特定区块链共识状态的更新，包括对当前状态的承诺，可以通过“轻客户端''算法以明确定义的方式进行验证。

### **Commitment Proof / 承诺证明**

承诺证明是一种证明结构，用于证明特定键是否映射到承诺集中的特定值。

### **Handler Module / 处理模块**

IBC 处理模块是状态机中对 ICS 25 子协议的实现，负责管理客户端、连接和通道，以及对证明进行验证并对数据包的承诺进行适当地存储。

### **Routing Module / 路由模块**

IBC路由模块是状态机中对 ICS 26 子协议的实现，在处理模块以及状态机上使用了路由模块外部接口的其他模块之间将数据包进行分发。

### **Datagram / 数据报**

数据报是指通过某些物理网络传输的非明文字节串，由账本的状态机中实现的 IBC 路由模块进行处理。 在某些实现中，包可以是特定于账本的交易或消息数据结构中的一个字段，其中还包含其他信息（例如，垃圾邮件预防费用，防止重现随机数，路由到 IBC 处理程序的类型标识符等） 。 所有 IBC 子协议（例如，建立连接、创建通道、发送数据包等）都是根据包的集合和协议来定义的，以便通过路由模块处理它们。

### **Connection / 连接**

连接是两条链上包含了所连接的账本中的共识状态信息的持久化数据集。意味着，更改所连接的两条链其中一条链上的共识状态会改变另一条链的连接对象的状态。

### **Channel / 通道**

通道是两条链上包含了用于促进数据包排序、“有且只有一次”发送和预防重放的元数据。通过通道发送的数据包会更改其内部状态。通道与连接之间是多对一的关系——也就是说一个连接可以拥有任意数量的相关联的通道，并且所有通道必须所属于某个连接，且连接必须先与通道建立。

### **Packet / 数据包**

数据包是一种特殊的数据结构，具有与序列相关的元数据（由IBC规范定义）和一个不透明的值字段，称为数据包数据（具有由应用层定义的语义，例如通证的名称和数量）。 数据包通过特定的通道发送（以及特定的连接）。

### **Module / 模块**

模块是特定区块链状态机的子组件，可以与 IBC 的处理逻辑进行交互并根据发送或接收的特定 IBC 数据包的数据字段更改账本状态（例如，铸币或销毁币）。

### **Handshake / 握手**

握手是一类涉及多个包的子协议，通常用于初始化两个相关链上的某些公共状态，例如彼此共识算法的可信状态等。

### **Sub-protocol / 子协议**

子协议定义了一系列必须实现的包类型和功能，应用 IBC 进行跨链的区块链必须有对应的 IBC 处理模块来实现这些协议。

包必须通过外部中继器程序在链之间中继。 假定该中继器过程以任意方式运行-安全特性不受其行为的影响，尽管进步通常取决于至少一个正确的中继器过程的存在。

IBC 子协议被认定为是两条链A和B之间的相互作用——这两条链之间没有先验区别，并且假定它们正在执行相同的正确的 IBC 协议。 按照惯例，A 只是在子协议中排在第一位的链，而 B 则在第二条协议中排在第一位。 协议定义通常应避免在变量名中包含A和B以避免混淆（因为链本身不知道它们在协议中是A还是B）。

### **Authentication / 身份验证**

身份验证是确保包实际上是由特定链以 IBC 处理程序定义的方式发送的属性。

## Properties Definitions / 属性定义

### **Finality / 最终确定性**

*最终确定性*是指在不考虑有关验证者集合行为的某些假设的情况下，某个特定的区块被最终确认并且不可再更改，由共识算法提供的可量化保证。IBC 协议需要最终确定性，尽管它不一定是绝对的（例如，针对中本聪共识算法的确定性阈值将提供确定性，但要遵守有关矿工行为的经济假设）。

### **Misbehaviour / 恶意行为**

恶意行为是由共识算法定义的一类共识错误，可由该共识算法的轻客户端检测。

### **Equivocation / 存疑行为**

存疑行为是由一个或多个验证者犯下的一类特定的共识错误，它们以无效的方式对不同的区块提案进行投票。 所有的存疑行为都是恶意行为。

### **Data availability / 数据可用性**

数据可用性是指链下中继处理器在一定时间范围内从世界状态中提取数据的能力。

### **Data confidentiality / 数据保密性**

数据机密性是状态机节点在不损害 IBC 协议功能的情况下拒绝向特定方提供特定数据的能力。

### **Non-repudiability / 不可否认性**

*不可否认性*是指状态极无法成功地质疑已发送的特定数据包或已经提交的特定状态。 IBC 是具备不可否认性的协议，状态机对模块数据的选择是保密的。

### **Consensus liveness / 共识活跃度**

共识活跃度是特定节点的共识算法对出块的持续性参与度。

### **Transactional liveness / 交易活跃度**

交易活跃度是指由特定节点的共识算法持续性地对传入的交易进行确认的参与度（哪些交易应根据上下文明确）。 交易活跃度需要共识活跃度，但是共识活跃度不一定提供交易活跃度。 交易活跃度意味着对交易的审查阻力。

### **Bounded consensus liveness / 有界共识活跃度**

有届共识活跃度是指在特定界限内的共识活跃度。

### **Bounded transactional liveness / 有届交易活跃度**

有届交易活跃度是指在特定界限内的交易活跃度。

### **Exactly-once safety / 有且只有一次安全性**

有且只有一次安全性是指一个数据包不会被多次确认。

### **Deliver-or-timeout safety / 抵达或超时安全性**

抵达或超时安全性是指数据包要么是抵达并执行要么超时这两种可能的结果回执给发送方的属性。

### **Constant (w.r.t. complexity) / 复杂度常量**

当提到空间或时间复杂度时，代表 O(1).

## **What's IBC? / IBC 是什么？**

IBC 是一种可靠的安全的链间通信协议，其中模块是包括可复制状态机（区块链或分布式账本）在内的在独立机器上运行的确定性程序。

IBC 可以被构建在在安全可靠的模块间通信上的应用程序所使用。典型的应用包括跨链资产转移、原子交换、多链智能合约以及各类数据和代码片段。

## **What is NOT IBC? / IBC 不是什么？**

IBC 不是一个应用层的协议：它只负责处理数据的传输、认证和可靠性问题。

IBC 不是一个原子交换的协议：支持任意跨链数据的传输和计算。

IBC 不是一个通证转移协议：通证转移是使用 IBC 协议的一种潜在的应用场景。

IBC 不是一个分片协议：这里不存在一个从这些链中分离出来的状态机，而是不同种类的区块链拥有不同的状态机，她们拥有彼此分享一些共享的接口。

IBC 不是一个二层扩容（链下扩容）协议：所有应用 IBC 的链都位于同一层，这些链并不需要一条单独的主链或单个验证者集合，尽管它们可能占据网络拓扑中的不同点。

## **Scope / 范围**

IBC 旨在处理在独立计算机上的模块之间中继的结构化数据包的身份验证，传输和排序。 该协议是在两台计算机上的模块之间定义的，但同时被设计来可以被在以任意拓扑连接下任意数量的机器上任意数量的模块之间同时安全地使用。

## **Interfaces / 接口**

IBC 一方面位于智能合约、其他状态机组件或状态机上其他独立的应用程序逻辑等这些模块之间，另一方面位于基础共识协议，机器和网络基础结构（例如TCP / IP）之间。

IBC 为模块提供了一组功能，类似于为一个模块提供与该状态机上其他的模块进行互操作的功能：在已建立的连接和通道上发送数据包和接收数据包——除了用于管理协议状态的调用外：建立和关闭连接和通道、选择连接、通道和数据包传递选项外，还包括检查连接和通道的状态。

IBC 假设 ICS 2中定义的基础共识协议和机器的功能和特性，主要是最终确定性（或最终确定性阀值），易于验证的共识记录和简单的键/值存储功能。在网络方面，IBC 仅需要保障最终的数据传递——不假定身份验证、同步或排序属性。

### Protocol Relations / 协议关系

```
+------------------------------+                           +------------------------------+
| Distributed Ledger A         |                           | Distributed Ledger B         |
|                              |                           |                              |
| +--------------------------+ |                           | +--------------------------+ |
| | State Machine            | |                           | | State Machine            | |
| |                          | |                           | |                          | |
| | +----------+     +-----+ | |        +---------+        | | +-----+     +----------+ | |
| | | Module A | <-> | IBC | | | <----> | Relayer | <----> | | | IBC | <-> | Module B | | |
| | +----------+     +-----+ | |        +---------+        | | +-----+     +----------+ | |
| +--------------------------+ |                           | +--------------------------+ |
+------------------------------+                           +------------------------------+
```

## **Operation / 可操作性**

IBC 的主要目的是为了在独立主机上运行的模块之间提供可靠的、经过身份验证的有序的通信，这需要以下领域的协议逻辑：

### **Data relay / 数据中继**

在 IBC 的架构中，模块之间并不是通过在网络基础设施上直接向彼此发送消息，而是先创建消息，然后通过监听“中继进程”对消息进行物理层面的中继。IBC 假定存在一组中继进程，这些中继进程可以访问基础网络协议堆栈（可能是TCP / IP，UDP / IP 或 QUIC / IP）和物理互连基础设施。 这些中继进程监听着应用了 IBC 协议的一组主机，连续扫描每台主机的状态，并在向外提交数据包时在另一台主机上执行交易。 为了正确操作并在两台主机之间建立连接的进度，IBC 仅要求至少存在一个可以在主机之间进行中继的正确且实时的中继程序。

### **Data confidentiality & legibility / 数据保密性和可识别性**

IBC 协议仅要求使 IBC 协议正确执行所需的最小数据可识别性（以标准格式序列化），并且状态机可以选择使该数据仅对特定中继器可用（尽管其详细信息超出本规范的范围）。 该数据包括共识状态、客户端（或译为轻节点）、连接、通道和数据包信息，以及在状态中用于验证或排除特定键/值对所必需的任何辅助状态结构。 所有必须证明给另一台主机的数据也必须具备可识别性， 即，必须以本规范定义的格式进行序列化。

### **Reliablility / 可靠性**

网络层和中继器进程可能以任意方式运行，丢弃、重新排序或复制数据包，有意尝试发送无效交易或以拜占庭方式进行操作。这一定不能损害 IBC 的安全性或活跃度。这是由为发送在 IBC 连接上的每个数据包分配一个序列号来实现的，该序列号由接收方上的 IBC 处理程序（状态机中实现了 IBC 的部分）检查，并提供一种方法，让发送方在发送更多数据包或采取进一步措施之前，去检查接收方实际上已经接收并处理了该数据包。密码学承诺用于防止包的伪造：发送方机器对外发数据包进行承诺，而接收方计算机检查这些承诺，因此中继程序在传输过程中更改的包将被拒绝。 IBC还支持无序通道，该通道不强制对发送的数据包进行排序，但仍强调严格一次发送的原则。

### **Flow control / 流程控制**

IBC 不会提供对计算层面或者经济层面的流程控制规定。机器的底层结构将具有自身的吞吐量限制和流程控制机制（例如 ETH 的“燃料”机制）。应用层面的经济流控制——根据内容对数据包的费率进行限制——或许对提升安全性（对任一状态机的状态值进行限定）和控制拜占庭容错带来的危害（提供挑战期，在挑战期内，证明如果具有多签行为可以关闭其连接）是有帮助的。例如，通过 IBC 通道进行价值跨链的应用可能希望通过限制每个区块所包含的跨链交易额，来限制潜在的拜占庭问题带来的危害。IBC 为模块提供了拒绝数据包的功能，并为上层的应用协议预留了具体的空间去处理其细节。

### **Authentication / 身份认证**

在 IBC 中的所有包必须是通过身份认证的：由发送链的共识算法完成的块必须通过加密承诺提交跨链数据包，并且接收链的 IBC 处理模块必须在采取进一步行动之前验证包中的共识记录和加密承诺证明。

### **Statefulness / 有状态性**

如上所述，可靠性，流量控制和身份验证要求 IBC 初始化并维护每个数据流的某些状态信息。 此信息分为两个抽象：连接和通道。 每个连接对象都包含有关已连接主机的共识状态信息。通道是对一对特定的两个模块而言的，通道均包含有关协商的编码和多路复用选项以及状态和序列号的信息。 当两个模块希望进行通信时，它们必须在其两台机器之间找到一个现有的连接和通道，否则，则需要初始化一个新的连接和通道。 初始化连接和通道都需要进行多次握手，一旦握手完成，中继的数据包将根据需要进行身份验证，编码和排序。

### **Multiplexing / 多路复用**

为了允许单个主机中的许多模块能够同时使用 IBC 建立的连接，IBC 在每个连接中提供了一组通道，每个通道唯一地标识按序发送包的数据流（对于已构建通道的模块） ，并确保发送目的链的对应模块做到“精确一次”。 通常希望一个通道与主机上的单个模块进行关联，但是一对多和多对一的通道也是可能的。 通道的数量是无限的，通道数不受限制，从而促进并发吞吐量仅受底层计算机的吞吐量限制，而跟踪共识信息只需一个连接即可（因此，使用某一连接的所有通道共同承担验证共识记录的成本）。

### **Serialisation / 连贯性**

IBC 充当了彼此无法互通的机器之间的接口边界，并且必须提供基于最小的数据结构编码和数据包结构的足够的互理解性，使得两台都正确实现 IBC 协议的机器能够相互理解。 为此，IBC 规范定义了数据结构的规范编码——proto3 格式，用于在通过 IBC 进行通信的两台机器之间进行序列化、中继或检查证明。

## **Dataflow / 数据流**

IBC 可以被概念化为分层协议栈，通过该协议栈，数据从上到下（在发送IBC数据包时）和自下而上（在接收IBC数据包时）流过。

“处理逻辑”是状态机中实现 IBC 协议的部分，该状态机负责将模块之间的调用与数据包之间进行转换，并在通道和连接之间进行适当的路由。

我们来考虑两条链之间的 IBC 数据包的路径——我们先称之为路径 A 和路径 B，我们来观察数据的流向以及每个模块所对应的子协议：

### Diagram

```
+---------------------------------------------------------------------------------------------+
| Distributed Ledger A                                                                        |
|                                                                                             |
| +----------+     +----------------------------------------------------------+               |
| |          |     | IBC Module                                               |               |
| | Module A | --> |                                                          | --> Consensus |
| |          |     | Handler --> Packet --> Channel --> Connection --> Client |               |
| +----------+     +----------------------------------------------------------+               |
+---------------------------------------------------------------------------------------------+

    +---------+
==> | Relayer | ==>
    +---------+

+--------------------------------------------------------------------------------------------+
| Distributed Ledger B                                                                       |
|                                                                                            |
|               +---------------------------------------------------------+     +----------+ |
|               | IBC Module                                              |     |          | |
| Consensus --> |                                                         | --> | Module B | |
|               | Client -> Connection --> Channel --> Packet --> Handler |     |          | |
|               +---------------------------------------------------------+     +----------+ |
+--------------------------------------------------------------------------------------------+
```

### Steps

1. On chain 

   A / 在链 A 上

   1. Module A / 模块 A（特定应用）
   2. Handler / 处理程序（在不同子协议中定义的实现部分）
   3. Packet / 数据包（在子协议 ICS 04 中定义）
   4. Channel / 通道（在子协议 ICS 04 中定义）
   5. Connection / 连接（在子协议 ICS 03 中定义）
   6. Client / 客户端（在子协议 ICS 02 中定义）
   7. Consensus / 共识（确认流出数据包中的交易）

2. Off-chain / 链下部分 

   1. Relayer / 中继层（在子协议 ICS 18 中定义）

3. On chain 

   B / 在链 B 上

   1. Consensus / 共识（确认流入数据包中的交易）
   2. Client / 客户端（在子协议 ICS 02 中定义）
   3. Connection / 连接（在子协议 ICS 03 中定义）
   4. Channel / 通道（在子协议 ICS 04 中定义）
   5. Packet / 数据包（在子协议 ICS 04 中定义）
   6. Handler / 处理程序（在不同子协议中定义的实现部分）
   7. Module B / 模块 B（特定应用）

## **Versatility / 多功能性**

IBC 被设计为通用协议。 该协议支持异构区块链，这些链的状态机用不同的语言来实现。在 IBC 上编写的应用可以被组合起来，并且 IBC 协议本身可以实现自动化。

### **Heterogeneity / 异构性**

IBC 可以由满足要求的任何共识算法和状态机（较短的最终确定时间、恒定大小的状态承诺和简洁的承诺证明）来实现。 IBC 协议处理数据身份验证、传输和排序（这是任何多链应用程序的共同要求），但与应用程序本身的语义无关。 通过 IBC 连接的异构链必须足够了解兼容的应用程序层接口（例如通证转移接口），但是一旦通过IBC接口处理程序，状态机就可以支持任意定制的功能（例如摒弃部分交易）。

### **Composability / 组合性**

协议开发者和用户都可以将在 IBC 之上编写的应用程序组合在一起。 IBC 定义了一组用于身份验证、传输和排序的原型，以及一组用于资产和数据语义的应用层标准。 支持兼容标准的链可以连接在一起，选择去创建这一连接（或重用连接）的任何用户可以进行交易。资产和数据可以在多个链上自动（“多跳”）和手动中继（ 通过依次发送几个 IBC 中继交易）。

### **Automatability / 自动性**

IBC 中的“用户”或“参与者”（具有启动连接、创建频道、发送数据包、报告拜占庭欺诈等行为）可以是但不一定是人类。 模块、智能合约和自动化的练下进程可以利用该协议（例如，要支付用于计算的燃料成本），并可以自行采取行动或协同行动。 设计跨多个链的复杂交互（例如利用三步连接去握手或者多跳的通证转移），使得除了单一初始行为外的所有动作都可以从用户的定义中抽象出来。 最终，我们有可能实现：自动启动一个新的区块链（模块化物理基础设施配置）、启动 IBC 连接、并完全自动地使用新建链的状态机和流量。

## **Modularity / 模块性**

IBC 被设计为模块化协议。 该协议被构造为一系列具有明确安全属性和要求的分层组件。 特定层上组件的实现可以有所不同（例如不同的共识算法或连接建立过程），只要它们为高层提供必要的属性（例如最终确定性，< 1/3 拜占庭安全或在两条链上嵌入受信任的状态）。 状态机仅需要了解 IBC 协议的兼容子集（例如，轻客户端对彼此共识的验证算法）即可安全地进行交互。

## **Locality / 局部性**

IBC被设计为本地协议，这意味着仅由两个连接链的信息才能推断出 IBC 双向连接的安全性和正确性。 身份验证原型的安全性要求仅涉及连接中的区块链的共识算法和验证者集合。一条链仅需要了解所连接的链的状态信息就已经足够了（不论那些链背后是否还连接其他的链）。

### **Locality of communication & information / 通信和信息的局部性**

IBC 对其运行的区块链网络的拓扑结构不做任何假设，也不依赖任何特征。 无需查看全局的区块链网络拓扑：安全性和正确性可以由两条链之间的单个连接和对网络拓扑中的子图的分析推理得出。用户和链可以由给定的他们已知的和假定正确的网络图就可以推验证假设和推断风险。

IBC 中不需要一条“根链”——整个网络的某些子网可能会演变成中心辐射状结构，其他子网可能与其保持连接，其他子网可能仍采用更奇特的拓扑结构。 通道是端到端的，在第一个版本中，IBC 仅支持单跳路径，但将来将支持多跳路径（尽管由于涉及共识算法正确性假设，因此自动路由不一定存在可能性和安全性）。

但是，应用数据可能具有协议参与者需要注意的显著的非本地属性，例如通证的原始区域（可能已在复杂的多跳路径上发送），原始权益和为其提供跨链交易验证的验证人身份信息，或与管理 non-fungible 通证私钥管理相关联的原始智能合约。 IBC 协议本身不需要理解这些非本地属性，但是需要用户和更高级别的应用程序需要。

### **Locality of correctness assumptions & security / 正确假设和安全的局部性**

IBC 的参与者（在链或智能合约层面以上）选择将哪些共识算法、状态机和验证人假定为行为端正的（以某种特定的方式运行，例如仅会出现小于 1/3 的拜占庭行为）以及以哪种方式去做这个假定。 假设 IBC 协议正确实现，则参与者永远不会面临因拜占庭行、验证人提交的虚假交易或由不明确的假定正确的链所带来的应用层面的违规增发的风险。 假定正确性对于在所预期的大型网络拓扑中互联的区块链来讲尤为重要，在这种拓扑中，偶尔可能会有一些链和验证人集合出现拜占庭行为——IBC 较保守的实现，一定程度上限制了风险并和可能造成的危害。

### **Locality of permissioning / 授权的局部性**

通过 IBC 的行为（例如建立连接、创建通道或发送数据包）是需要通过参与连接的两条链上的状态机和参与者进行本地化授权的。 各个链可以选择要求许可机制（例如治理）对特定的应用层操作（例如委托安全度的削减）进行批准，但是对于基本协议而言，操作是无需经过许可的——默认情况下 ，无需任何批准即可创建连接、创建通道和发送数据包。 当然，用户自己必须检查每个 IBC 连接的状态和共识，自行决定这个连接是否足够安全能够被使用（例如，其存储的状态是受信的）。

## Efficiency / 效能

IBC 被设计为一种高效的协议：链间数据和资产中继的摊销成本应主要包括底层状态交易和与数据包相关的操作（例如通证转移）的成本，以及一些较小的固定开销。
